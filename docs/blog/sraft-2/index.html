<!doctype html><html lang=zh-cn><title>sraft (二) | SDTTTTT's Log</title><meta charset=utf-8><meta name=generator content="Hugo 0.76.5"><meta name=description content="这是开发日志嘛?"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://sdttttt.github.io/css/index.css><link rel=canonical href=https://sdttttt.github.io/blog/sraft-2/><link rel=alternate type=application/rss+xml href title="SDTTTTT's Log"><header><a href=https://sdttttt.github.io/ class=title>SDTTTTT's Log</a><nav><a href=/about/>About</a></nav></header><article><header><h1>sraft (二)</h1><time datetime=2020-09-22T12:08:44+08:00>September 22, 2020</time></header><p>昨天草草的完成了通信协议适配器, 至少能做到自由切换协议,
纵看整个编程模型还是有缺陷,
StateMachine的内部结构比我想的要复杂的多,
多个状态实现的切换,以及对一些内部事件的触发.
StateMachine模块的密度和其他模块完全不同. 反而RaftKernel存在的意义却减小了.</p><p>经过昨天晚上和今早的考虑, 我决定将StateMachine作为一个Slot,接入到RaftKernel中去,
RaftKernel现在同时也是状态机本身, Slot是可变的, 可以有Leader, Follower, Candidate三种插槽,每个Slot都有不同的扩展字段, 比如Leader会需要登记每个Node的同步日志的深度以及状态. 并且每个Slot都有自己的事件处理实现.</p><p>没想到第一天开发结束就会遇到麻烦, 看来sraft以后的苦难还不少&mldr;</p></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js></script><div id=gitalk-container style=margin:auto></div><script>var gitalk=new Gitalk({clientID:'747ab8530477531c3d25',clientSecret:'af2cc18e4c27998636a6a3c82af0064f38574170',repo:'sdttttt.github.io',owner:'sdttttt',admin:['sdttttt'],id:location.pathname,distractionFreeMode:true})
gitalk.render('gitalk-container')</script></html>