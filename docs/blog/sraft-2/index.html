<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>sraft (二) | SDTTTTT</title><link rel=stylesheet href=/sass/main.min.12754930aaca2409561861a9f13c52153f073ef96d63061a9a330c250f392fcb.css></head><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/>SDTTTTT</a></div><div class=flex><button id=dark-mode-button></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>sraft (二)</h1><div class=post-meta><div>By sdttttt on <time>September 22, 2020</time></div><div class=tags><a href=/tags/log/>log</a></div></div></div></div></header></article><div class=article-post><p>昨天草草的完成了通信协议适配器, 至少能做到自由切换协议,
纵看整个编程模型还是有缺陷,
StateMachine的内部结构比我想的要复杂的多,
多个状态实现的切换,以及对一些内部事件的触发.
StateMachine模块的密度和其他模块完全不同. 反而RaftKernel存在的意义却减小了.</p><p>经过昨天晚上和今早的考虑, 我决定将StateMachine作为一个Slot,接入到RaftKernel中去,
RaftKernel现在同时也是状态机本身, Slot是可变的, 可以有Leader, Follower, Candidate三种插槽,每个Slot都有不同的扩展字段, 比如Leader会需要登记每个Node的同步日志的深度以及状态. 并且每个Slot都有自己的事件处理实现.</p><p>没想到第一天开发结束就会遇到麻烦, 看来sraft以后的苦难还不少&mldr;</p></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/blog/sraft-1/ title="Previous post (older)"><span>Previous</span>
Sraft (一)</a>
<a rel=next href=/blog/grc-1/ title="Next post (newer)"><span>Next</span>
GRC (一)</a></nav></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links></nav></section><script async src=/js/features.min.f77830aff4bfb7a756b9ef68388f40d2187cb0046d41790785074eb8cd054cc3.js data-enable-footnotes=true></script></footer></body></html>