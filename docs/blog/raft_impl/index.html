<!doctype html><html lang=zh-cn><title>Raft实现的思考 | SDTTTTT's Log</title><meta charset=utf-8><meta name=generator content="Hugo 0.76.5"><meta name=description content="Hugo ---sdttttt"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://sdttttt.github.io/css/index.css><link rel=canonical href=https://sdttttt.github.io/blog/raft_impl/><link rel=alternate type=application/rss+xml href title="SDTTTTT's Log"><header><a href=https://sdttttt.github.io/ class=title>SDTTTTT's Log</a><nav><a href=/about/>About</a></nav></header><article><header><h1>Raft实现的思考</h1><time datetime=2020-06-25T19:02:23+08:00>June 25, 2020</time></header><p>比较Raft算法和Paxos算法之后,确实能感受到Raft算法更加接近正常人的思维逻辑, Paxos反而比较<code>专业?</code></p><p>本文会说一些Raft算法实现上的一些考量, 我目前还没有正式开始开发Raft的实现.
文中所有的内容仅供参考.</p><p>Raft最基础分为三种状态: <strong>Leader</strong>, <strong>Follower</strong>, <strong>Candidate</strong>.
整个Raft主体即是一个状态机.</p><p>每个RaftNode都需要处理外部的事件.所以我们可以采用事件驱动模型.</p><p>整体我们可以拆分为三个部分:</p><ul><li>RaftProcessor: 处理事件的处理器.</li><li>EventDispatcher: 负责接收外部任务,发送给Raft本体, 或者接收Raft本体发来的事件,向外发布.</li><li>LogSynchronizer: 同步LogBuffer中的日志到Raft本体.</li></ul><p>三个部分可以使用Channel来到达互相通信.</p><p><img src=https://static01.imgkr.com/temp/4b34da085c8742018791aa36e4921210.jpg alt></p></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js></script><div id=gitalk-container style=margin:auto></div><script>var gitalk=new Gitalk({clientID:'747ab8530477531c3d25',clientSecret:'af2cc18e4c27998636a6a3c82af0064f38574170',repo:'sdttttt.github.io',owner:'sdttttt',admin:['sdttttt'],id:location.pathname,distractionFreeMode:true})
gitalk.render('gitalk-container')</script></html>