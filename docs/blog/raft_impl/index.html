<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>Raft实现的思考 | SDTTTTT</title><link rel=stylesheet href=/sass/main.min.12754930aaca2409561861a9f13c52153f073ef96d63061a9a330c250f392fcb.css></head><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/>SDTTTTT</a></div><div class=flex><button id=dark-mode-button></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Raft实现的思考</h1><div class=post-meta><div>By sdttttt on <time>June 25, 2020</time></div><div class=tags><a href=/tags/distribute-system/>distribute system</a></div></div></div></div></header></article><div class=article-post><p>比较Raft算法和Paxos算法之后,确实能感受到Raft算法更加接近正常人的思维逻辑, Paxos反而比较<code>专业?</code></p><p>本文会说一些Raft算法实现上的一些考量, 我目前还没有正式开始开发Raft的实现.
文中所有的内容仅供参考.</p><p>Raft最基础分为三种状态: <strong>Leader</strong>, <strong>Follower</strong>, <strong>Candidate</strong>.
整个Raft主体即是一个状态机.</p><p>每个RaftNode都需要处理外部的事件.所以我们可以采用事件驱动模型.</p><p>整体我们可以拆分为三个部分:</p><ul><li>RaftProcessor: 处理事件的处理器.</li><li>EventDispatcher: 负责接收外部任务,发送给Raft本体, 或者接收Raft本体发来的事件,向外发布.</li><li>LogSynchronizer: 同步LogBuffer中的日志到Raft本体.</li></ul><p>三个部分可以使用Channel来到达互相通信.</p><p><img src=https://static01.imgkr.com/temp/4b34da085c8742018791aa36e4921210.jpg alt></p></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/blog/kanon/ title="Previous post (older)"><span>Previous</span>
Kanon</a>
<a rel=next href=/blog/thread_pool_executor/ title="Next post (newer)"><span>Next</span>
Thread Pool Executor 运行细节</a></nav></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links></nav></section><script async src=/js/features.min.f77830aff4bfb7a756b9ef68388f40d2187cb0046d41790785074eb8cd054cc3.js data-enable-footnotes=true></script></footer></body></html>