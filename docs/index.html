<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="theme-color" content="#000" />
    <title>
        
             
                SDTTTTT 
             
            &middot; Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        
    </title>

    
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css"
        integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
    
    
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Condensed:wght@300&family=Merriweather:ital,wght@0,300;0,700;1,300&display=swap" rel="stylesheet">
    <link rel="icon" href="/img/favicon.ico" type="image/x-icon">

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="">
    
    
    <meta name="description" content="Lorem ipsum dolor sit amet, consectetur adipiscing elit.">
    

    
    <meta name="author" content="Sdttttt"></head>
<body>
        <div class="container"><div id="navbar" class="pure-menu pure-menu-open pure-menu-horizontal pure-menu-scrollable">
    <a href="/" class="pure-menu-heading">
         
            SDTTTTT 
         
    </a>
    <ul class="pure-menu-list">
        <li class="pure-menu-item">
            <a href="/posts" class="pure-menu-link">
                <i class="fa fa-archive"></i>
                Articles
            </a>
        </li>
        <li class="pure-menu-item">
            <a href="/tags" class="pure-menu-link">
                <i class="fas fa-comments"></i>
                Categories
            </a>
        </li>
        <li class="pure-menu-item">
            <a href="/about" class="pure-menu-link">
                <i class="fas fa-smile"></i>
                About
            </a>
        </li>
    </ul>
    <ul class="pure-menu-list pull-right">
        
        <li class="pure-menu-item">
            <a href="https://github.com/sdttttt" title="Github" class="pure-menu-link">
                <i class="fab fa-github"></i>
                <span class="hide">Github</span>
            </a>
        </li>
        
        
        <li class="pure-menu-item">
            <a href="http://twitter.com/shiina38092638" title="@pravin" class="pure-menu-link">
                <i class="fab fa-twitter-square"></i>
                <span class="hide">Twitter</span>
            </a>
        </li>
        
        
        
        
        <li class="pure-menu-item">
            <a href="https://www.facebook.com/sdzzzzz" title="Facebook" class="pure-menu-link">
                <i class="fab fa-facebook"></i>
                <span class="hide">Facebook</span>
            </a>
        </li>
        
        <li class="pure-menu-item">
            <a href="/posts/index.xml" title="Atom Feed" class="pure-menu-link">
                <i class="fas fa-rss-square"></i>
                <span class="hide">RSS Feed</span>
            </a>
        </li>
    </ul>
</div>
<div class="pure-u-1">
    <div class="pad">
    </div>
</div>
<div class="pure-g">

<div id="content" class="pure-u-1 pure-u-md-3-4 pure-u-sm-1">
    

    <div class="pad">
<div class="date">
    <time pubdate="2020-09-03">September 3, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/gosyncpool/">GoSyncPool</a></h1>
    <div class="tags">
        
        
        <a href="/tags/golang" class="pure-button">Golang</a>
        
    </div>
    <p>今天在看Sentinel-golang源码的时候发现sentinel在内部使用了sync.Pool该结构体.看到Sync和Pool的我第一反应想到应该是线程池之类的东西.在实际看过原理之后发现并不是这样的.</p>
<hr>
<p>sync.Pool 的目的是为了利用对象的复用来减小GC压力.但是开销比较高.要斟酌使用.</p>
<p>Pool和golang的GMP协程模型的关系比较大.
sync.Pool对每一个P(系统线程)都分配了一个本地池.</p>
<p>本地池中有2个属性，分别是private和share。
private只能被当前P访问，share可以被不同的P访问.</p>
<p>在执行Get or Put的时候.会对应当前执行P的本地池.</p>
<h4 id="get">Get</h4>
<ol>
<li>尝试从本地P对应的那个本地池中获取一个对象值, 并从本地池冲删除该值。</li>
<li>如果获取失败，那么从共享池中获取, 并从共享队列中删除该值。</li>
<li>如果获取失败，那么从其他P的共享池中偷一个过来，并删除共享池中的该值(p.getSlow())。</li>
<li>如果仍然失败，那么直接通过New()分配一个返回值，注意这个分配的值不会被放入池中。New()返回用户注册的New函数的值，如果用户未注册New，那么返回nil。</li>
</ol>
<h4 id="put">Put</h4>
<ol>
<li>如果放入的值为空，直接return.</li>
<li>检查当前goroutine的是否设置对象池私有值，如果没有则将x赋值给其私有成员，并将x设置为nil。</li>
<li>如果当前goroutine私有值已经被设置，那么将该值追加到共享列表。</li>
</ol>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-08-30">August 30, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/btree/">B Tree</a></h1>
    <div class="tags">
        
        
        <a href="/tags/data-structure" class="pure-button">Data Structure</a>
        
    </div>
    <p>这篇文章以数据库存储的数据结构来引出本文的重点<strong>B树</strong>,以及后面还有另一种数据结构<strong>B+树</strong>.</p>
<p>试想, 如果你想持久化大量的数据在硬盘上, 同时还希望能高效的查询和修改他们, 你会怎么做, 使用哪种数据结构.</p>
<p>数组和链表, 他们的缺点很明显, 我们寻找数据需要遍历整个数据结构, 试想一下你的数据库中有50PB的数据, 这个开销是我们无法接受的.</p>
<p>哈希表, 通过给定的数据通过Hash函数生成对应的索引, 能非常高效的找到对应的数据. 但是, 哈希表不能用于范围查询.</p>
<p>二叉树, 一种使用二分法作为查询算法的数据结构, 在内存中, 二叉树的效率确实非常高, 但是如果是在硬盘上, 每次读取节点, 都需要进行一次IO, 随着数据量的增大, 深度逐渐加深, 二叉树的效率就会大大降低.</p>
<h2 id="b-tree">B Tree</h2>
<p>B树存在一些和二叉树不一样的地方: 二叉树每个节点只保存一份数据以及两个指针, B树在每个节点都可以保留一样数量的数据和指针, 指针的数量为数据的数量+1.</p>
<p>在B树中还有存在一个概念, 阶数, 它决定了该B树每个节点应该有多少数据以及指针.</p>
<h3 id="rules">Rules</h3>
<ul>
<li>
<p>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；例如一个节点能存放3份数据, 该数据需要从左到右增序存放, 1, 2, 3.</p>
</li>
<li>
<p>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外(注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉)；</p>
</li>
<li>
<p>关键字数：子节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个(注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
</li>
<li>
<p>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
</li>
</ul>
<h3 id="find">Find</h3>
<p>我们用一个图和一个实际的例子来理解B树(这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A):</p>
<p><img src="/DataStructure/BT.jpg" alt="BT"></p>
<p>如上图我要从上图中找到E字母，查找流程如下:</p>
<ol>
<li>
<p>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M(26个字母顺序)，所以往找到指向左边的子节点(二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点)；</p>
</li>
<li>
<p>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</p>
</li>
<li>
<p>拿到E和F，因为E=E 所以直接返回关键字和指针信息(如果树结构里面没有包含所要查找的节点则返回null).</p>
</li>
</ol>
<h3 id="insert">Insert</h3>
<p>下次更新.</p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-08-29">August 29, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/blogupgrade/">Blog Upgrade</a></h1>
    <div class="tags">
        
        
        <a href="/tags/blog" class="pure-button">Blog</a>
        
    </div>
    <p>这几天修改了这个Blog的主题, 加载速度应该是更快了, 而且优化了整个项目的自动部署. 取消了双仓库的部署策略, 在部署任务的执行上也用上了异步.</p>
<p>现在每次修改完成后的生成以及部署的速度比以前快了大概40%左右.但是访问<strong>Github Page</strong>的速度还是一如既往的的满.</p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-08-25">August 25, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/thread_pool_executor/">Thread Pool Executor 运行细节</a></h1>
    <div class="tags">
        
        
        <a href="/tags/java" class="pure-button">Java</a>
        
    </div>
    <p>先说说线程池本身, 由于线程资源本身在计算机中比较昂贵, 创建和销毁都有相当的开销, 所以在一些处理简单但是并发量大的场景使用一个请求对应一个线程的是不明智的选择.</p>
<p>ThreadPoolExecutor是Java中线程池的一种实现. 构造函数如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span> <span style="color:#75715e">// 核心线程数量
</span><span style="color:#75715e"></span>                              <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span> <span style="color:#75715e">// 最大线程数量
</span><span style="color:#75715e"></span>                              <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span> <span style="color:#75715e">// 存活时间
</span><span style="color:#75715e"></span>                              TimeUnit unit<span style="color:#f92672">,</span> <span style="color:#75715e">// 时间单位
</span><span style="color:#75715e"></span>                              BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue <span style="color:#75715e">// 来个列队
</span><span style="color:#75715e"></span>                        <span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">,</span> maximumPoolSize<span style="color:#f92672">,</span> keepAliveTime<span style="color:#f92672">,</span> unit<span style="color:#f92672">,</span> workQueue<span style="color:#f92672">,</span>
             Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultThreadFactory</span><span style="color:#f92672">(),</span> defaultHandler<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>提交任务时的运行如下:</p>
<ul>
<li>如果正在运行的线程数 &lt; coreSize，马上创建线程执行该task，不排队等待；</li>
<li>如果正在运行的线程数 &gt;= coreSize，把该task放入阻塞队列；</li>
<li>如果队列已满 &amp;&amp; 正在运行的线程数 &lt; maximumPoolSize，创建新的线程执行该task；</li>
<li>如果队列已满 &amp;&amp; 正在运行的线程数 &gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。</li>
<li>从worker线程自己的角度来看，当worker的task执行结束之后，循环从阻塞队列中取出任务执行。</li>
</ul>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-06-25">June 25, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/raft_impl/">Raft实现的思考</a></h1>
    <div class="tags">
        
        
        <a href="/tags/distribute-system" class="pure-button">distribute system</a>
        
    </div>
    <p>比较Raft算法和Paxos算法之后,确实能感受到Raft算法更加接近正常人的思维逻辑, Paxos反而比较<code>专业?</code></p>
<p>本文会说一些Raft算法实现上的一些考量, 我目前还没有正式开始开发Raft的实现.
文中所有的内容仅供参考.</p>
<p>Raft最基础分为三种状态: <strong>Leader</strong>, <strong>Follower</strong>, <strong>Candidate</strong>.
整个Raft主体即是一个状态机.</p>
<p>每个RaftNode都需要处理外部的事件.所以我们可以采用事件驱动模型.</p>
<p>整体我们可以拆分为三个部分:</p>
<ul>
<li>RaftProcessor: 处理事件的处理器.</li>
<li>EventDispatcher: 负责接收外部任务,发送给Raft本体, 或者接收Raft本体发来的事件,向外发布.</li>
<li>LogSynchronizer: 同步LogBuffer中的日志到Raft本体.</li>
</ul>
<p>三个部分可以使用Channel来到达互相通信.</p>
<p><img src="https://static01.imgkr.com/temp/4b34da085c8742018791aa36e4921210.jpg" alt=""></p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-06-12">June 12, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/kanon/">Kanon</a></h1>
    <div class="tags">
        
        
        <a href="/tags/gal" class="pure-button">GAL</a>
        
    </div>
    <iframe frameborder="no" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26134218&auto=1&height=66"></iframe>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<p>有一段时间没有玩过<code>GALGAME</code>了.</p>
<p>所以就去尝试玩了<code>Kanon</code>.</p>
<p>总之就是, <strong>非常后悔</strong>.</p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-06-02">June 2, 2020</time>
    <span class="author">by sdttttt</span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/database_storage/">Database Storage</a></h1>
    <div class="tags">
        
    </div>
    <p><strong>CMU Database System 15-445/645</strong> 储存 Part 1</p>
<p>数据库存储的数据在 FS(File System) 中是以 <strong>块(Block)</strong> 的方式表示的.</p>
<p>实际上你很可能已经见到过了,在MySQL中的数据库就是以一切Block文件的方式存储的.</p>
<p>这篇文章会告诉你目前常见的数据库存储方式.</p>
<hr>
<p>最开始用<strong>Tuple Storage</strong>来尝试改善数据库的存储结构.</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/0029ea52-6d5b-4989-a8e0-a7dec2e0d49c.png" alt=""></p>
<p>它的工作原理比较简单, 每一个<strong>Page</strong>维护一个<strong>Header</strong>,
Header中会包含一些Page的元数据,以及被存储数据的偏移值.</p>
<p>每当插入一个Tuple,我们就会Update Header中的偏移值.</p>
<p>这个设计中存在比较大的问题, 如果我们删除了底下Tuple,就不得不移动所有Tuple.
如果不移动数据, 那我们也要花费高昂的代价去维护Header中Page的meta数据.</p>
<hr>
<p>目前最常见的就是<strong>Slotted Pages</strong>的方式去存储数据.
在不同数据库中的实现细节可能不同,但是从高级层面来讲,大多数数据库系统,
用的都是这种方式去存储数据.</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/a47909a8-e0e6-48ea-a0b7-e3e327d7fdf2.png" alt=""></p>
<p>每个Page中有三个部分:</p>
<ul>
<li><strong>Header</strong>: 保存最基本的matedata, 还包含一些checksum和访问时间之类的.</li>
<li><strong>SlotArray</strong>: 将每一个特定的Slot映射到对应Tuple的偏移值上.</li>
<li><strong>TupleArray</strong>: 储存每一个Tuple.</li>
</ul>
<p>在这个结构中Header后面紧接这SoltArray, 而Tuple是从Page的尾部开始存储的.
每个Page存储的Tuple的个数是固定的.</p>
<p>如果Tuple被删除,我们也只需要删除固定的Solt就行. 
空出来的空间碎片,可以由数据库的空间整理功能去完成.
维护每个Tuple的成本也比较小.只需要改变Solt就可以.</p>
<hr>
<p>最后讲一个Demo来演示数据库的工作过程.</p>
<p>假如我想要找一个叫A的人,我会先去查找索引.
从索引里我知道A的Page是123, Solt是2.
我去找管理Pages的人,让他把Page123的指针给我,
然后拿着Page的指针,找到Solt2中的偏移地址,找到了A这个人.</p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-05-25">May 25, 2020</time>
    <span class="author">by </span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/red-black-tree/">Red Black Tree</a></h1>
    <div class="tags">
        
        
        <a href="/tags/data-structure" class="pure-button">Data Structure</a>
        
    </div>
    <p>半年前在研究<code>HashMap</code>的时候已经学习过红黑树的规则原理了.
不过现在又遇到就忘记是怎么实现的了.(只知道这玩意是用来平衡树的)
这次就把这个数据结构做一个了断.</p>
<h3 id="性质">性质</h3>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
</ul>
<p>满足这5个性质就能保证红黑树是平衡的.</p>
<h3 id="insert">Insert</h3>
<p>插入的节点默认是红色的.因为这样可以最大限度满足红黑树的5个性质.</p>
<p>请试想一下.如果插入的节点是红色:</p>
<ul>
<li>性质1可以满足.</li>
<li>性质2可以满足.</li>
<li>性质3可以满足(插入红色节点后自动衍生出2个黑色的NIL节点).</li>
<li>性质4可能没法满足(新插入的节点的父节点也是红色).</li>
<li>性质5可能没法满足(父节点是黑色时就不行).</li>
</ul>
<p>然后是红黑树节点的左右旋.</p>
<p><img src="https://gitee.com/sdttttt/images/raw/master//1323444-ff870251222c460e.gif" alt=""></p>
<p><img src="https://gitee.com/sdttttt/images/raw/master//1323444-3f68be339d2a3983.gif" alt=""></p>
<p>看懂没? 节点的旋转大概就是这样。</p>
<p>然后就是要分插入的情况了.</p>
<ul>
<li>
<p>第一种：根节点为空。这种情况，将node的颜色改为黑色即可.</p>
</li>
<li>
<p>第二种: node的父节点为黑色。这种情况不需要做修改.</p>
</li>
<li>
<p>第三种: node的父节点为红色 (根据性质3，N的祖父节点必为黑色). 这种情况和变换规则都比较多.下面细说&hellip;</p>
<ul>
<li>node的叔父节点为红色。这种情况，将N的父节点和叔父节点的颜色都改为黑色，若祖父节点是跟节点就将其改为黑色，否则将其颜色改为红色，并以祖父节点为插入的目标节点开始重新递归修复红黑树.</li>
</ul>
<p><img src="https://gitee.com/sdttttt/images/raw/master//Red-black_tree_insert_case_3.png" alt=""></p>
<ul>
<li>node的叔父节点为黑色，且node和node的父节点在同一边 (即父节点为祖父的左儿子时，N也是父节点的左儿子。父节点为祖父节点的右儿子时。N也是父节点的右儿子)。以父节点为祖父节的左儿子为例，将父节点改为黑色，祖父节点改为红色，然后以祖父节点为基准右旋。(N为父节点右儿子时做相应的左旋)</li>
</ul>
<p><img src="https://gitee.com/sdttttt/images/raw/master//Red-black_tree_insert_case_5.png" alt=""></p>
<ul>
<li>node的叔父节点为黑色，且node和node的父节点不在同一边 (即父节点为祖父的左儿子时，N是父节点的右儿子。父节点为祖父节点的右儿子时。N也是父节点左右儿子)。以父节点为祖父节点的左儿子为例。以父节点为基准，进行左旋，然后以父节点为目标插入节点进入情况3的b情况进行操作。</li>
</ul>
<p><img src="https://gitee.com/sdttttt/images/raw/master//Red-black_tree_insert_case_4.png" alt=""></p>
</li>
</ul>
<h3 id="delete">Delete</h3>
<p>这个以后再说.</p>
<h3 id="search">Search</h3>
<p>红黑树算是搜索二叉树的一个子集，<code>Search</code>方法是相同的。</p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-05-20">May 20, 2020</time>
    <span class="author">by </span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/tree_rust/">Tree by Rust implement</a></h1>
    <div class="tags">
        
        
        <a href="/tags/rust" class="pure-button">Rust</a>
        
        
        <a href="/tags/data-structure" class="pure-button">Data Structure</a>
        
    </div>
    <p><img src="/code/carbon2.png" alt=""></p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pad">
<div class="date">
    <time pubdate="2020-05-20">May 20, 2020</time>
    <span class="author">by </span>
</div>

<article>
    <h1><a href="https://sdttttt.github.io/post/stack_rust/">Stack by Rust implement</a></h1>
    <div class="tags">
        
        
        <a href="/tags/rust" class="pure-button">Rust</a>
        
        
        <a href="/tags/data-structure" class="pure-button">Data Structure</a>
        
    </div>
    <p><img src="/code/carbon.png" alt=""></p>

</article>
</div>
    <div class="pad"></div>

    

    <div class="pagination">
        
        <a class="pure-button pagination-item older" href="/page/2/">Older</a>
        

        
        <span class="pagination-item newer">Newer</span>
        
    </div>
</div>


                
<div id="sidebar" class="pure-u-1 pure-u-md-1-4 pure-u-sm-1">
    <div class="pad">
        <a name="about"></a>
        <h3>About Me</h3>
        <div style="text-align: center;">
            <img src="/me.png" alt="Sdttttt" class="pure-img" />
            <p><em>突如其来的变故使得本就不富裕的晦气小伙雪上加霜.</em></p>
        </div>

        <h3>Latest Articles</h3>
        <div class="pure-menu pure-menu-open">
            <ul class="pure-menu-list">
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/gosyncpool/" class="pure-menu-link">GoSyncPool<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/btree/" class="pure-menu-link">B Tree<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/blogupgrade/" class="pure-menu-link">Blog Upgrade<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/thread_pool_executor/" class="pure-menu-link">Thread Pool Executor 运行细节<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/raft_impl/" class="pure-menu-link">Raft实现的思考<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/kanon/" class="pure-menu-link">Kanon<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/database_storage/" class="pure-menu-link">Database Storage<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/red-black-tree/" class="pure-menu-link">Red Black Tree<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/tree_rust/" class="pure-menu-link">Tree by Rust implement<br>
                        <small></small>
                    </a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="https://sdttttt.github.io/post/stack_rust/" class="pure-menu-link">Stack by Rust implement<br>
                        <small></small>
                    </a>
                </li>
                
            </ul>
        </div>

        <h3>Categories</h3>
        <div style="text-align:center" class="tags">
            
            
            <a href="/tags/data-structure" class="pure-button"> data-structure
                <small>(4)</small></a>
            
            
            
            <a href="/tags/penetration-test" class="pure-button"> penetration-test
                <small>(3)</small></a>
            
            
            
            <a href="/tags/assembly" class="pure-button"> assembly
                <small>(2)</small></a>
            
            
            
            <a href="/tags/blog" class="pure-button"> blog
                <small>(2)</small></a>
            
            
            
            <a href="/tags/cicd" class="pure-button"> cicd
                <small>(2)</small></a>
            
            
            
            <a href="/tags/design" class="pure-button"> design
                <small>(2)</small></a>
            
            
            
            <a href="/tags/microservice" class="pure-button"> microservice
                <small>(2)</small></a>
            
            
            
            <a href="/tags/rust" class="pure-button"> rust
                <small>(2)</small></a>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div> 
</div> 

                
            </div><div class="pure-g">
	<footer class="pure-u-1 pure-u-md-1 pure-u-sm-1">
		<p>This page and its contents are copyright &copy; 2020,
			<a href="">Sdttttt</a>.</p>
		<p><a href="https://github.com/pravin/hugo-theme-prav">Theme Prav</a> by <a href="https://cto.me.uk">Pravin
				Paratey</a></p>
	</footer>

	<script defer src="https://use.fontawesome.com/releases/v5.0.9/js/all.js"
		integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl"
		crossorigin="anonymous"></script>
</div></div></body>
</html>
