<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on SDTTTTT's Log</title><link>https://sdttttt.github.io/tags/go/</link><description>Recent content in Go on SDTTTTT's Log</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020, SDTTTTT.</copyright><lastBuildDate>Thu, 08 Apr 2021 17:26:07 +0800</lastBuildDate><atom:link href="https://sdttttt.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Unsafe</title><link>https://sdttttt.github.io/blog/go-unsafe/</link><pubDate>Thu, 08 Apr 2021 17:26:07 +0800</pubDate><guid>https://sdttttt.github.io/blog/go-unsafe/</guid><description>看了一些关于unsafe包的文章,长话短说:
unsafe.Pointer就是一个纯指针, 它很聪明, 如果对象改变了地址它也会自动改变.并且保持对对象的引用, 这样对象不会被回收.
uintptr就是一个比较大的整型, 能容下任何指针地址, 但是这个不会跟随对象改变地址&amp;hellip;而且对象还会被回收&amp;hellip;</description></item><item><title>Go的map的个什么结构</title><link>https://sdttttt.github.io/blog/go-map/</link><pubDate>Fri, 13 Nov 2020 15:31:53 +0800</pubDate><guid>https://sdttttt.github.io/blog/go-map/</guid><description>实际上Go的map和Java7之前的HashMap, 非常相似。都是Array + LinkedTable的结构。
结构 map数据结构由runtime/map.go/hmap定义:
type hmap struct { count int // 当前保存的元素个数 ... B uint8 // 指示bucket数组的大小 ... buckets unsafe.Pointer // bucket数组指针，数组的大小为2^B ... } bucket数据结构由runtime/map.go/bmap定义：
type bmap struct { tophash [8]uint8 //存储哈希值的高8位 data byte[1] //key value数据:key/key/key/.../value/value/value... overflow *bmap //溢出bucket的地址 } 这里使用的数组对齐方式来存放数据。overflow指向下一个bucket.
工作流程 首先通过key计算Hash值，通过Hash的低位，计算出该元素需要存放在buckets中的哪一个bucket. 如果Hash冲突，也就是当前bucket已经有人进去了。那么就使用该bucket的overflow指向自己的bucket.
查找元素也是大同小异。</description></item></channel></rss>