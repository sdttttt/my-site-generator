<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on SDTTTTT</title><link>https://sdttttt.github.io/tags/rust/</link><description>Recent content in Rust on SDTTTTT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 12 Nov 2020 09:46:53 +0800</lastBuildDate><atom:link href="https://sdttttt.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Impl and Dyn on Rust</title><link>https://sdttttt.github.io/blog/rust-impl-and-dyn/</link><pubDate>Thu, 12 Nov 2020 09:46:53 +0800</pubDate><guid>https://sdttttt.github.io/blog/rust-impl-and-dyn/</guid><description>我们先来看这样一段代码:
1 2 3 4 5 implViewforButton{...}implViewforText{...} 我们看到Button和Text都实现了View属性, 抽象是一种不错的设计程序的方法, 帮助我们透明化的使用外部提供的API. 然后我们可能会下意识的写出下面的代码:
1 2 3 4 5 6 7 8 9 10 11 12 /// 这种代码实际上会让人感到疑惑. View究竟是个特性还是一个对象. /// 这里的View是一个类型, 所以我们需要写成 `impl View`. /// 不过`impl View` 不能用于多个trait实现的返回. 但是可以作为入参. pubfn something()-&amp;gt; View{if...{Button{...}}else{Text{...}}} 这段代码无法通过编译, 原因就是返回值View需要在编译器确认大小. 我们需要把它装成一个胖指针.
1 2 3 pubfn something()-&amp;gt; Box&amp;lt;View&amp;gt;{...} 嗯,这样就好很多. 但是编译器会爆种, 提出一个警告, 希望你把Box&amp;lt;View&amp;gt;改为Box&amp;lt;dyn View&amp;gt;.
这又是什么意思?
dyn 是动态的缩写, 意义其实很明显. 使用dyn修饰的类型, 会在程序执行期动态分发. 会有一定的RUNTIME开销.
1 2 3 pubfn something()-&amp;gt; Box&amp;lt;dynView&amp;gt;{.</description></item><item><title>Tree by Rust implement</title><link>https://sdttttt.github.io/blog/tree_rust/</link><pubDate>Wed, 20 May 2020 19:14:33 +0800</pubDate><guid>https://sdttttt.github.io/blog/tree_rust/</guid><description/></item><item><title>Stack by Rust implement</title><link>https://sdttttt.github.io/blog/stack_rust/</link><pubDate>Wed, 20 May 2020 19:01:23 +0800</pubDate><guid>https://sdttttt.github.io/blog/stack_rust/</guid><description/></item></channel></rss>