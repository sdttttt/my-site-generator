<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on SDTTTTT's Smelly fish Rotten shrimp 📓</title><link>https://sdttttt.github.io/tags/rust/</link><description>Recent content in Rust on SDTTTTT's Smelly fish Rotten shrimp 📓</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020, SDTTTTT.</copyright><lastBuildDate>Thu, 12 Nov 2020 09:46:53 +0800</lastBuildDate><atom:link href="https://sdttttt.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Impl and Dyn on Rust</title><link>https://sdttttt.github.io/blog/rust-impl-and-dyn/</link><pubDate>Thu, 12 Nov 2020 09:46:53 +0800</pubDate><guid>https://sdttttt.github.io/blog/rust-impl-and-dyn/</guid><description>这篇文章会讲解关于Rust中impl和dyn这两个关键词的作用. 帮助你更好的编写Rust程序.
我们先来看这样一段代码:
impl View for Button { ... } impl View for Text { ... } 我们看到Button和Text都实现了View属性, 抽象是一种不错的设计程序的方法, 帮助我们透明化的使用外部提供的API. 然后我们可能会下意识的写出下面的代码:
/// 这种代码实际上会让人感到疑惑. View究竟是个特性还是一个对象. /// 这里的View是一个类型, 所以我们需要写成 `impl View`. // 不过`impl View` 不能用于多个trait实现的返回. 但是可以作为入参. pub fn something() -&amp;gt; View { if ... { Button { ... } } else { Text { ... } } } 这段代码无法通过编译, 原因就是返回值View需要在编译器确认大小. 我们需要把它装成一个胖指针.
pub fn something() -&amp;gt; Box&amp;lt;View&amp;gt; {...} 嗯,这样就好很多. 但是编译器会爆种, 提出一个警告, 希望你把Box&amp;lt;View&amp;gt;改为Box&amp;lt;dyn View&amp;gt;.</description></item><item><title>Tree by Rust implement</title><link>https://sdttttt.github.io/blog/tree_rust/</link><pubDate>Wed, 20 May 2020 19:14:33 +0800</pubDate><guid>https://sdttttt.github.io/blog/tree_rust/</guid><description/></item><item><title>Stack by Rust implement</title><link>https://sdttttt.github.io/blog/stack_rust/</link><pubDate>Wed, 20 May 2020 19:01:23 +0800</pubDate><guid>https://sdttttt.github.io/blog/stack_rust/</guid><description/></item></channel></rss>