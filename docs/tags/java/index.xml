<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on SDTTTTT's Smelly fish Rotten shrimp 📓</title><link>https://sdttttt.github.io/tags/java/</link><description>Recent content in java on SDTTTTT's Smelly fish Rotten shrimp 📓</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020, SDTTTTT.</copyright><lastBuildDate>Fri, 05 Feb 2021 10:57:31 +0800</lastBuildDate><atom:link href="https://sdttttt.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>记录一次Gradle构建的困难</title><link>https://sdttttt.github.io/blog/gradle-build-for-idiotc4t/</link><pubDate>Fri, 05 Feb 2021 10:57:31 +0800</pubDate><guid>https://sdttttt.github.io/blog/gradle-build-for-idiotc4t/</guid><description>受@idiotc4t所托, 我拿到了一个Java项目, 目的是要把这玩意编译出来, 最初我还以为和以前的Java项目类似, 只要mvn build 就能一了百了, 没想到这次拿到的是一个使用gradle构建的项目.
gradle的出现比maven晚, 它们都是用来构建运行在JVM上的应用使用的, gradle可以使用编程语言来自定义你的构建流程, 类似C的makefile(这个比喻不太好其实), 或者是JavaScript的gulp. gradle解决了maven的一些特点, 比如xml的配置繁琐, 看着就头大, 以及构建步骤的灵活控制. 总之很牛逼就是了, 也比较难上手.
由于我以前使用过一段时间的gradle, 所以我知道用gradle打jar包的困难. (gradle这个工具通常都是给Android开发者用的, 默认没有提供打成Jar包的选项, 所以打出来什么包, 得看缘分.)
当我运行gradle build后, 光速构建完成, 我定神一看, 没有工程文件目录, 倒是有一个jar包 ,这个jar包就14KB, 好家伙, 肯定没构建成功. (正常的java程序绝对不会这么小, 一般肯定是1MB以上) 输入java -jar一看, 果然:
...jar: 没有主清单属性 总之我在网上查了半天都没发现解决方法. 最后把目光转向代码, 最后发现在代码中都没有声明包路径&amp;hellip;
(嘶&amp;hellip;.这厮在README里是怎么打包的???我怀疑有这B留了一手)
最后用宇宙第一IDE(IDEA)重构了整个包的代码, 补上了包路径. 再次尝试gradle build,终于看到了工程文件.
写完了, 摸了.</description></item><item><title>RocketMQ 3.3.4 Broker</title><link>https://sdttttt.github.io/blog/rocketmq-comments/</link><pubDate>Tue, 13 Oct 2020 16:56:11 +0800</pubDate><guid>https://sdttttt.github.io/blog/rocketmq-comments/</guid><description>差不多可以看消息队列的源码了。 在下从gitee上找到了rocketmq的早期版本（3.2.2）， 坏消息是这个2014年的项目里没有单元测试极少, 调试会比较困难. 好消息是这个时候的RocketMQ还没开源多久，里面有很多中文注释。看起来会很舒服。
我们从Broker开始涂鸦。关于RocketMQ中每个角色的作用这里不再陈述：
先从初始化开始：
public static void main(String[] args) { start(createBrokerController(args)); } rocketmq是从commandline启动的，createBrokerController函数比较长， 会有很多额外的逻辑干扰你，我这里直接说重点：
读取环境变量，没有就用默认值。 解析命令行参数。 初始化配置类。 打印默认配置内容。 检查NameServer地址设置是否正确。 检查broker的类型（master，slave） 初始化日志配置类。 再次打印。 初始化服务控制对象. 最后增加一个关闭Broker时触发的hook. 服务控制对象： Broker各个服务控制器，包括存储层配置，配置文件版本号，消费进度存储，Consumer连接、订阅关系管理等等。
以上就是createBrokerController的内容，函数虽然长，但是并不复杂。
下面为start函数的内容, 在main中的start函数实际上是去委托了BrokerController去执行.
public void start() throws Exception { // 启动Broker的各层服务 if (this.messageStore != null) { this.messageStore.start(); } if (this.remotingServer != null) { this.remotingServer.start(); } if (this.brokerOuterAPI != null) { this.brokerOuterAPI.start(); } if (this.pullRequestHoldService != null) { this.</description></item><item><title>MyBatis 源码分析</title><link>https://sdttttt.github.io/blog/mybatissourcecode/</link><pubDate>Thu, 10 Sep 2020 22:15:42 +0800</pubDate><guid>https://sdttttt.github.io/blog/mybatissourcecode/</guid><description>其实很早就想写一篇 iBatis 的源码分析了, 不过有段时间去学习 Go 了, Java 就放下了, 最近 重新捡起 Java 就把以前没填的坑,填一下.
Init 现在开始正片.
首先是 iBatis 的初始化工作.我们看下面的代码:
// `BlogDataSourceFactory`的主要作用: 通过你的配置文件, 初始化一个DataSource DataSource dataSource = BlogDataSourceFactory.getBlogDataSource(); // JdbcTransactionFactory一个New就能得到, 没什么依赖条件 TransactionFactory transactionFactory = new JdbcTransactionFactory(); // Environment要你交出数据源和事务工厂还有你的环境是开发还是生产 Environment environment = new Environment(&amp;#34;development&amp;#34;, transactionFactory, dataSource); // Configuration有基本上你所有的配置 Configuration configuration = new Configuration(environment); // 添加你的mapper到配置列表中, 等会我们去分析它 configuration.addMapper(BlogMapper.class); // 通过你的配置类,让我们初始化一个SqlSessionFactory! 我们终于进入正题了!! // 可能你觉得很快... 其实本人在这里面分析还是花了很长时间 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 好, 上文有说configuration.addMapper(BlogMapper.class)这个方法, 现在我们来分析一下它.
// 这个是Configuration中的方法, 它实际上是委托mapperRegistry去执行 public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) { mapperRegistry.</description></item><item><title>Thread Pool Executor 运行细节</title><link>https://sdttttt.github.io/blog/thread_pool_executor/</link><pubDate>Tue, 25 Aug 2020 17:29:15 +0800</pubDate><guid>https://sdttttt.github.io/blog/thread_pool_executor/</guid><description>先说说线程池本身, 由于线程资源本身在计算机中比较昂贵, 创建和销毁都有相当的开销, 所以在一些处理简单但是并发量大的场景使用一个请求对应一个线程的是不明智的选择.
ThreadPoolExecutor是Java中线程池的一种实现. 构造函数如下:
public ThreadPoolExecutor(int corePoolSize, // 核心线程数量 int maximumPoolSize, // 最大线程数量 long keepAliveTime, // 存活时间 TimeUnit unit, // 时间单位 BlockingQueue&amp;lt;Runnable&amp;gt; workQueue // 来个列队 ) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } 提交任务时的运行如下:
如果正在运行的线程数 &amp;lt; coreSize，马上创建线程执行该task，不排队等待； 如果正在运行的线程数 &amp;gt;= coreSize，把该task放入阻塞队列； 如果队列已满 &amp;amp;&amp;amp; 正在运行的线程数 &amp;lt; maximumPoolSize，创建新的线程执行该task； 如果队列已满 &amp;amp;&amp;amp; 正在运行的线程数 &amp;gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。 从worker线程自己的角度来看，当worker的task执行结束之后，循环从阻塞队列中取出任务执行。</description></item></channel></rss>