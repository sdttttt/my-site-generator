<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on SDTTTTT</title><link>https://sdttttt.github.io/tags/javascript/</link><description>Recent content in Javascript on SDTTTTT</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 18 Jan 2021 16:49:35 +0800</lastBuildDate><atom:link href="https://sdttttt.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>节流与防抖</title><link>https://sdttttt.github.io/blog/js-1/</link><pubDate>Mon, 18 Jan 2021 16:49:35 +0800</pubDate><guid>https://sdttttt.github.io/blog/js-1/</guid><description>闲来无事在网上翻一些关于 Javascript 的一些搞基技巧，就发现了节流与防抖这两种设计模式。
上个星期在编写搜索框的时候就已经写过类似的代码 （搜索框输入关键词会实时去服务器上搜索，考虑到服务器压力就把代码加了限制，每 500ms 最多搜索一次，实际上这就是类似防抖的设计，只是我还不知道这个叫防抖&amp;hellip;）
下面是搜索框的限制代码：
1 2 3 4 5 6 7 8 watch(searchText, (newVal) =&amp;gt; { clearTimeout(searchTimer); searchTimer = setTimeout( () =&amp;gt; //...需要限制的逻辑 ), 500 ); }); 原理非常简单，通过定时器实现，一旦现有状态改变就说明有新的输入，然后清除老的定时器，新设置定时器。
今天在网上冲浪又学到了一种新的设计：节流
直接看代码吧：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 watch(searchText, (newVal) =&amp;gt; { if(isStop) { return } isStop = true; setTimeout( () =&amp;gt; { //.</description></item></channel></rss>